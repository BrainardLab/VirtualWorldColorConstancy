%% Generate recipes as in ToyVirtualWorld, using with VirtualScenesEngine.
%
% This is BSH making a start at updating our recipe generation code to use
% RenderToolbox4 and VirtualScenesEngine, instead of the old RenderToolbox3
% code.
%
% I'm sorry to say I probably won't be able to finish.  But I am hoping to
% make enough of a start that you can see how to generate vwcc-style
% recipes using the VirtualScenesEngine, and I hope that will be enough for
% you to pick up and run with.  Qapla'!
%

clear;
clc;

%% Choose batch render options.
hints.fov = deg2rad(60);
hints.imageHeight = 240;
hints.imageWidth = 320;
hints.renderer = 'Mitsuba';
hints.recipeName = 'vwccPoc';

projectName = 'VirtualWorldColorConstancy';
hints.workingFolder = fullfile(getpref(projectName, 'baseFolder'), 'Working');


%% Confgigure where to find assets.
aioPrefs.locations = aioLocation( ...
    'name', 'VirtualScenesExampleAssets', ...
    'strategy', 'AioFileSystemStrategy', ...
    'baseDir', fullfile(vseaRoot(), 'examples'));


%% Choose base scenes to work with.
baseSceneNames = {'CheckerBoard', 'IndoorPlant', 'Library', ...
    'Mill', 'TableChairs', 'Warehouse'};

% this will load models using mexximp
%   from a toolbox called VirtualScenesExampleAssets
%   which is similar to our older VirtualScenes repository
nBaseScenes = numel(baseSceneNames);
baseScenes = cell(1, nBaseScenes);
baseSceneInfos = cell(1, nBaseScenes);
for bb = 1:nBaseScenes
    name = baseSceneNames{bb};
    [baseScenes{bb}, baseSceneInfos{bb}] = VseModel.fromAsset('BaseScenes', name, ...
        'aioPrefs', aioPrefs, ...
        'nameFilter', 'blend$');
end


%% Choose objects to insert.
shapeNames = {'Barrel', 'BigBall', 'ChampagneBottle', ...
    'RingToy', 'SmallBall', 'Xylophone'};

% this will load models, like above
nShapes = numel(shapeNames);
shapes = cell(1, nShapes);
for ss = 1:nShapes
    name = shapeNames{ss};
    shapes{ss} = VseModel.fromAsset('Objects', name, ...
        'aioPrefs', aioPrefs, ...
        'nameFilter', 'blend$');
end


%% Chose which base scene and which shapes and lights to insert.
baseSceneIndex = randi(nBaseScenes);
baseSceneInfo = baseSceneInfos{bb};

nInsertShapes = 3;
shapeIndexes = randi(nShapes, [1, nInsertShapes]);

nInsertLights = 2;
lightIndexes = randi(nShapes, [1, nInsertLights]);


%% For each shape insert, choose a random spatial transformation.
insertShapes = cell(1, nInsertShapes);
for ss = 1:nInsertShapes
    shape = shapes{ss};
    
    rotationX = randi([0, 359]);
    shapeRotationY = randi([0, 359]);
    shapeRotationZ = randi([0, 359]);
    shapePosition = GetRandomPosition([0 0; 0 0; 0 0], baseSceneInfo.objectBox);
    shapeScale = 0.3 + rand()/2;
    shapeTransformation = mexximpScale(shapeScale) ...
        * mexximpRotate([1 0 0], rotationX) ...
        * mexximpRotate([0 1 0], shapeRotationY) ...
        * mexximpRotate([0 0 1], shapeRotationZ) ...
        * mexximpTranslate(shapePosition);
    
    insertShapes{ss} = shape.copy( ...
        'transformation', shapeTransformation);
end

% the first insert is the target
%   it will receive special attention from styles
insertShapes{1}.name = 'target';


%% For each light insert, choose a random spatial transformation.
insertShapes = cell(1, nInsertShapes);
for ll = 1:nInsertLights
    light = shapes{ll};
    
    rotationX = randi([0, 359]);
    shapeRotationY = randi([0, 359]);
    shapeRotationZ = randi([0, 359]);
    shapePosition = GetRandomPosition(sceneData.lightExcludeBox, sceneData.lightBox);
    shapeScale = 0.3 + rand()/2;
    shapeTransformation = mexximpScale(shapeScale) ...
        * mexximpRotate([1 0 0], rotationX) ...
        * mexximpRotate([0 1 0], shapeRotationY) ...
        * mexximpRotate([0 0 1], shapeRotationZ) ...
        * mexximpTranslate(shapePosition);
    
    insertShapes{ll} = light.copy( ...
        'transformation', shapeTransformation);
end
innerModels = [insertShapes{:}];

% the first insert is the target
%   it will receive special attention from styles
innerModels(1).name = 'target';


%% Build recipe, render, and preview.
baseScene = baseScenes{baseSceneIndex};
innerModels = [insertShapes{:} insertLights{:}];
styles.none = {};
recipe = vseBuildRecipe(baseScene, innerModels, styles, ...
    'hints', hints);

recipe = rtbExecuteRecipe(recipe);

imshow(uint8(recipe.processing.srgbMontage));

%% Notes.

% luminance levels
% reflectances

% full radiance rendering (a style)
% quick mask rendering (a style)
% make everything black except the target object area light (a style)

% assign reflectances in base scene (a style)
% assign illuminant spectra in base scene (a style)
% assign reflectances to inserted shapes (a style)
% assign reflectance to target shape (a style)
% choose a set of random lights to insert (nLights)
% assign illuminant spectra in inserted lights (a style)
% point the camera at the target shape

% build recipes
%   one style set is quick and make everything black
%   one style is full radiance and use "real" spectra
